var documenterSearchIndex = {"docs":
[{"location":"smoptimize/#Surrogate-model-optimization-1","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"","category":"section"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"A julia function can be optimized with","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"smoptimize","category":"page"},{"location":"smoptimize/#SurrogateModelOptim.smoptimize","page":"Surrogate model optimization","title":"SurrogateModelOptim.smoptimize","text":"smoptimize(f::Function, search_range::Array{Tuple{Float64,Float64},1}; options=Options())\n\nOptimize the function f in the range search_range using a Radial Basis Function based surrogate model.\n\n\n\n\n\n","category":"function"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"The goal is to minimize the function output.","category":"page"},{"location":"smoptimize/#Example-1","page":"Surrogate model optimization","title":"Example","text":"","category":"section"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"julia> using SurrogateModelOptim\njulia> rosenbrock_2D(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\njulia> search_range=[(-5.0,5.0),(-5.0,5.0)]\njulia> smoptimize(rosenbrock_2D, search_range)","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"Due to the high cost of creating several surrogates it is highly advisable to create the surrogate model in parallel. Start julia in parallel with > julia -p x where x is the number of available cores. The previous example can then be run as","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"julia> result = smoptimize(rosenbrock_2D, search_range;\n                    options=SurrogateModelOptim.Options(\n                    iterations=15,\n                    num_interpolants=N*x, #Where N is an integer number\n                    num_start_samples=5,\n                        ));","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"The default option num_interpolants=10, meaning that the surrogate model ensemble contains 10 RBF interpolants, has shown good performance for a variety of functions. The performance is typically good for smooth functions with or without noise. Discontinuous functions are not captured well by RBF interpolation, see the example section. The surrogate model returned in the results does not contain the last evaluated infill points by default. This can be turned on with the option create_final_surrogate=true. ","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"A few helper function are available to deal with the results type.","category":"page"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"best_fitness","category":"page"},{"location":"smoptimize/#BlackBoxOptim.best_fitness","page":"Surrogate model optimization","title":"BlackBoxOptim.best_fitness","text":"best_fitness(result::SurrogateResult)\n\nExtract the best fitness from the SurrogateResult type.\n\n\n\n\n\n","category":"function"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"best_candidate","category":"page"},{"location":"smoptimize/#BlackBoxOptim.best_candidate","page":"Surrogate model optimization","title":"BlackBoxOptim.best_candidate","text":"best_candidate(result::SurrogateResult)\n\nExtract the design parameters yielding the best fitness from the SurrogateResult type.\n\n\n\n\n\n","category":"function"},{"location":"smoptimize/#","page":"Surrogate model optimization","title":"Surrogate model optimization","text":"f_calls","category":"page"},{"location":"smoptimize/#SurrogateModelOptim.f_calls","page":"Surrogate model optimization","title":"SurrogateModelOptim.f_calls","text":"f_calls(result::SurrogateResult)\n\nExtract the number of function calls used from the SurrogateResult type.\n\n\n\n\n\n","category":"function"},{"location":"model_infill/#Model-infill-1","page":"Model infill","title":"Model infill","text":"","category":"section"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"New design locations can be found with","category":"page"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"model_infill","category":"page"},{"location":"model_infill/#SurrogateModelOptim.model_infill","page":"Model infill","title":"SurrogateModelOptim.model_infill","text":"model_infill(search_range::Vector{Tuple{Float64,Float64}},plan::AbstractArray{T,2},\nsamples::AbstractArray{T,2},sm_interpolant; options::Options=Options()) where T\n\nInfill function that calculates the location of new samples based on the supplied options. The returned options are updated to facilitate cycling through the infill objective functions.\n\n...\n\nArguments\n\nsearch_range::Vector{Tuple{Float64,Float64}:   a vector of tuples containing the lower and upper limits   for each dimension. length(search_range) is equal to number   of dimensions.\nplan::AbstractArray{T,2}:    sample locations where each column corresponds to the location of one point.   size(plan) = (num_dimensions,num_samples).\nsamples::AbstractArray{T,2}:   function value at each sample location. each column contains one value from   the corresponding plan location. size(samples) = (1,num_samples).\noptions=Options():    all options available to customize the surrogate infill.  \n\n...\n\n\n\n\n\n","category":"function"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"The infill criteria is optimized based on the supplied options. Custom criteria can be implemented and solved for by using the surrogate_model with your favourite optimization library.  ","category":"page"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"In the case where several infill points are requested, each infill criteria is used cyclically. If the number of requested infill points exceeds the number of infill criteria, a point from the pareto front of the infill objectives is selected. The selected points is the point which maximizes the distance to the already sampled points to explore the search space. In the case where the requested infill points can't be found without duplicates, a random point is added. This happens very rarely. Duplicates are never added. The infill type can be seen during run time with trace=:verbose, alternatively the returned results contain all the infill criteria used. ","category":"page"},{"location":"model_infill/#Example-1","page":"Model infill","title":"Example","text":"","category":"section"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"The package supplied model infill can be used as ","category":"page"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"julia> infill_plan, infill_type, infill_prediction, options = model_infill(search_range,plan,samples,sm_interpolant; options=SurrogateModelOptim.Options())","category":"page"},{"location":"model_infill/#","page":"Model infill","title":"Model infill","text":"note: Note\nThe options are updated to cycle through the infill_type.","category":"page"},{"location":"examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Most of the flexibility is left for the user to create and tailor to their specific needs. There are several examples located in examples/ of different ways the optimization package can be used. To run all simply do","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"julia> include(joinpath(dirname(pathof(SurrogateModelOptim)), \"../examples/test_all.jl\"))","category":"page"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Below is a brief explanation of the examples. ","category":"page"},{"location":"examples/#Noisy-optimization-1","page":"Examples","title":"Noisy optimization","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Optimization of noisy functions requires no special treatment except that smooth is used in the options. For most functions, even those with small amounts of noise, it is recommended to use smooth=:single.","category":"page"},{"location":"examples/#Categorical-optimization-1","page":"Examples","title":"Categorical optimization","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"The example shows how it is possible to constrain the optimization to discrete values.","category":"page"},{"location":"examples/#Multi-objective-optimization-1","page":"Examples","title":"Multi-objective optimization","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Multi-objective optimization can be performed by creating a separate surrogate of each objective. The surrogate can then be used with you favourite algorithm, in this example BlackBoxOptim.jl is used. In this example a random point is selected from the pareto front for infill. It would likely be better to add a space filling criteria when adding the infill points.","category":"page"},{"location":"examples/#Discontinuous-optimization-1","page":"Examples","title":"Discontinuous optimization","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"This example shows how the performance of the optimization suffers in regions of discontinuity. If possible, reformulate the problem so that it becomes smooth. If that is not possible it is better to use another optimization package, especially if the optimum is expected close to the discontinuity. Note that noise can be handled and is not considered to be a discontinuity. ","category":"page"},{"location":"examples/#Constrained-optimization-1","page":"Examples","title":"Constrained optimization","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Constrained optimization can be performed by adding an additional penalty after the surrogate model has been created. Note that it is important to add it after the creation to keep the function as smooth as possible. If it is added before the creation, the surrogate accuracy will suffer in the transition area where the penalty was added.","category":"page"},{"location":"examples/#Fast-options-1","page":"Examples","title":"Fast options","text":"","category":"section"},{"location":"examples/#","page":"Examples","title":"Examples","text":"Run an example using the options for running the optimisation fast. This is not a recommended settings to use. Use another optimisation package such as Optim.jl or BlackBoxOptim.jl if the function evaluation is fast compared to the surrogate model creation. Can be useful for faster validation of code. ","category":"page"},{"location":"surrogate_model/#Surrogate-model-1","page":"Surrogate model","title":"Surrogate model","text":"","category":"section"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"The surrogate model which is used for the optimization can be created manually with","category":"page"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"surrogate_model","category":"page"},{"location":"surrogate_model/#SurrogateModelOptim.surrogate_model","page":"Surrogate model","title":"SurrogateModelOptim.surrogate_model","text":"surrogate_model(plan::AbstractArray{T,2}, samples::AbstractArray{T,2}; options=Options()) where T\n\nReturns a surrogate model function based on an optimized Radial Basis Function interpolant. Depending on the supplied options; the kernel, kernel width and scaling of  input data is optimized.\n\n...\n\nArguments\n\nplan::AbstractArray{T,2}:    sample locations where each column corresponds to the location of one point.   size(plan) = (num_dimensions,num_samples).\nsamples::AbstractArray{T,2}:   function value at each sample location. each column contains one value from   the corresponding plan location. size(samples) = (1,num_samples).\noptions=Options():    all options available to customize the surrogate optimization.  \n\n...\n\n\n\n\n\n","category":"function"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"This enables the freedom to choose how it is optimized and used. When called, the  function value from each surrogate in the ensemble is returned.","category":"page"},{"location":"surrogate_model/#Example-1","page":"Surrogate model","title":"Example","text":"","category":"section"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"julia> rosenbrock_2D(x) = (1.0 - x[1])^2 + 100.0 * (x[2] - x[1]^2)^2\njulia> search_range=[(-5.0,5.0),(-5.0,5.0)]\n\n# Start from 5 Latin Hypercube Samples\njulia> num_samples=5\njulia> sampling_plan_opt_gens=10_000\njulia> plan = scaled_LHC_sampling_plan(search_range,num_samples,sampling_plan_opt_gens)\n\n# Evaluate the function \njulia> samples = mapslices(rosenbrock_2D,plan,dims=1)\n\n# Create the optimized surrogate model (optres contains the optimization results for the surrogate)\njulia> opt=SurrogateModelOptim.Options()\njulia> sm_interpolant, optres = surrogate_model(plan, samples;options=opt)","category":"page"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"The surrogate model is by default created using only Gaussian kernels. This can be changed by supplying several kernels, e.g. kerns = [ScatteredInterpolation.Gaussian, ScatteredInterpolation.InverseQuadratic, ScatteredInterpolation.InverseMultiquadratic]. For a limited number of rbf_opt_gens the surrogate model performance tends to be better using only one kernel to limit the search space when optimizing the surrogate hyperparameters. ","category":"page"},{"location":"surrogate_model/#","page":"Surrogate model","title":"Surrogate model","text":"Turning on verbosity with trace=:verbose can help with judging of the hyperparameter optimisation.","category":"page"},{"location":"options/#Options-1","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/#","page":"Options","title":"Options","text":"The available options are listed below. The performance using the default options has been good for several test functions, with and without noise. Make sure to set num_interpolants to a value which is a multiple of the number of processes used for the least amount of time to create the surrogate. Based on a small benchmark test, the number of interpolants has marginal improvement to the optimization above 10 interpolants. ","category":"page"},{"location":"options/#","page":"Options","title":"Options","text":"num_start_samples::Int = 5                                      # Samples included in the LHC sampling plan\ntrace::Symbol = :compact                                        # Print the progress. Options include :silent, :compact and :verbose\nsampling_plan_opt_gens::Int = 2_500                             # Iterations used to optimize the LHC sampling plan\nrippa::Bool = true                                              # Rippas algorithm to reduce computational effort optimizing the surrogate\nkerns = [ScatteredInterpolation.Gaussian,\n         ScatteredInterpolation.InverseMultiquadratic,\n         ScatteredInterpolation.InverseQuadratic]               # RBF kernels to choose from\nrbf_opt_gens::Int = 2_500                                       # Generations that the RBF hyperparameters are optimized\nconstrained_seed_gens::Int = 2_500                              # Generations optimising the RBF hyperparameters in a constrained\nrbf_opt_pop::Int = 50                                           # Population size of RBF hyperparameter optimization\nrbf_opt_method::Symbol = :adaptive_de_rand_1_bin_radiuslimited  # BlackBoxOptim optimization method for RBF hyperparameters\nrbf_dist_metric = Distances.Euclidean()                         # Distance metric used to create the RBF\nvariable_kernel_width::Bool = true                              # Allow individual kernels and widths for each sample\nvariable_dim_scaling::Bool = true                               # Linearly scale the input dimensions for best fit\ncond_max::Float64 = 5e12                                        # Maximum allowed condition number of RBF matrix A\ncond_check::Bool = false                                        # Does not check the condition number of RBF matrix A by default\nmax_rbf_width::Float64 = 1.0                                    # Maximum RBF width factor\nmin_rbf_width::Float64 = 0.0                                    # Minimum RBF width factor\nmax_scale::Float64 = 1.0                                        # Maximum linear input dimension scaling factor\nmin_scale::Float64 = 0.0                                        # Minimum linear input dimension scaling factor\nnum_interpolants::Int = 10                                      # Number of interpolants in ensemble\nsmooth = :single                                                # Apply smoothing factor, useful for functions with noise\n                                                                # false turned off, :single one factor for all points,\n                                                                # :variable individual factor for each point, \n                                                                # :single_user user supplied value\nmax_smooth::Float64 = 0.005                                     # Maximum smoothing factor \nsmooth_user::Float64 = 0.0                                      # User supplied smoothing factor, only applied if smooth = :single_user\niterations::Int64 = 5                                           # Number of infill iterations to be run\nnum_infill_points::Int64 = 1                                    # Number of infill points per iteration\nparallel_surrogate::Bool = true                                 # Create each surrogate in the ensemble in parallel\ninfill_funcs::Array{Symbol,1} = [:std,:median,:wstdmed03,\n                                 :median,:wstdmed06,:median,\n                                 :wstdmed09,:median]            # Infill criteria, cycled through \ninfill_iterations::Int64 = 25_000                               # Iterations to add infill points to the design space\ncreate_final_surrogate::Bool = false                            # Option to re-create the surrogate using all evaluated samples ","category":"page"},{"location":"options/#Smoothing-1","page":"Options","title":"Smoothing","text":"","category":"section"},{"location":"options/#","page":"Options","title":"Options","text":"smooth, max_smooth and smooth_user are all related to the ability of smoothing the RBF interpolant to handle cases with noise. The best performance is had when the smallest amount of smoothing is applied while being large enough to hinder high frequency oscillations in the resulting interpolant. If the input is noisy, set smooth to :single and the amount of smoothing applied is automatically optimized. The amount of smoothing is bound between 0 and max_smooth when optimized automatically. It can also be set to a fixed value with the option smooth = :single_user where the value is supplied with the smooth_user option.","category":"page"},{"location":"options/#Kernel-options-1","page":"Options","title":"Kernel options","text":"","category":"section"},{"location":"options/#","page":"Options","title":"Options","text":"variable_kernel_width is by default true meaning that the RBF kernel and the width of each kernel is optimized individually for each sampled point. This does increase the degrees of freedom which can lead to overfitting when the number of sample points is small. The performance when using variable_kernel_width = true can suffer initially when the number of samples is small but the overall convergence tends to be better. The recommendation is to leave the option true at all times. ","category":"page"},{"location":"options/#","page":"Options","title":"Options","text":"The number of hyperparameters to optimise increases with the number of points as  2N when variable_kernel_width is set to true. To increase convergence speed of the hyperparameter optimisation, a few initial iterations can be performed in the constrained space (as if variable_kernel_width=false) to seed the full unconstrained optimisation. This can increase convergence speed and is particularly useful when optimising using few rbf_opt_gens. constrained_seed_gens controls the number of iterations to perform in the  constrained space for seeding. It is recommended to use this as the convergence rate tends to  increase. ","category":"page"},{"location":"options/#","page":"Options","title":"Options","text":"Radial Basis Function interpolation is as the name suggests, radial in space. This can create problems when vastly differing input to output dimensions are used such as in the 2D Rosenbrock benchmark problem. In such cases the optimal radial width becomes a compromise between the two input dimensions. To solve this, the input dimensions can be linearly scaled automatically using variable_dim_scaling = true, which is the default. ","category":"page"},{"location":"#SurrogateModelOptim.jl-1","page":"Home","title":"SurrogateModelOptim.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SurrogateModelOptim is a Julia package for the optimization of expensive functions.  The surrogate model is based on an ensemble of Radial Basis Function interpolants with adaptive axis scaling.","category":"page"}]
}
